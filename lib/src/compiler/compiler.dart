// coverage:ignore-file
import 'dart:typed_data';

import 'package:antlr4/antlr4.dart';
import 'package:dscript_dart/dscript_dart.dart';
import 'package:dscript_dart/src/gen/antlr/dscriptParser.dart';
import 'package:dscript_dart/src/gen/antlr/dscriptVisitor.dart';
import 'package:equatable/equatable.dart';

part 'naivie_compiler.dart';
part 'instructions.dart';
part 'debug.dart';

/// Result of compiling a script.
class CompiledScript extends Equatable {
  /// Bytecode for each implementation.
  final Map<String, BytecodeFunction> implementations;

  /// The contract implemented by the script.
  final ContractSignature contract;

  /// Bytecode for each hook.
  final Map<String, BytecodeFunction> hooks;

  /// Permissions required by the script.
  final List<ScriptPermission> permissions;

  /// Bytecode functions for each global function.
  final Map<String, BytecodeFunction> functions;

  /// Metadata of the script.
  final ScriptMetadata metadata;

  /// Creates a compiled script with [implementations], [hooks] and [permissions].
  const CompiledScript({
    required this.implementations,
    required this.hooks,
    required this.permissions,
    required this.functions,
    required this.contract,
    required this.metadata,
  });

  @override
  List<Object?> get props =>
      [permissions, functions, implementations, hooks, contract];
}

/// Compiles an analyzed [script] into a [CompiledScript].
///
/// Optionally, you can swap out the compiler used with a custom one by overriding the
/// [compiler] function that takes a list of global variable declarations and returns a [Compiler] instance.
/// If not provided, the default [NaiveCompiler] is used.
CompiledScript compile(
  Script script, [
  Compiler Function(List<VarDeclContext> globals) compiler = NaiveCompiler.new,
]) {
  final impls = <String, BytecodeFunction>{};
  final hooks = <String, BytecodeFunction>{};
  final functions = <String, BytecodeFunction>{};

  for (final entry in script.functions.entries) {
    final visitor = compiler(script.globals);
    entry.value.accept(visitor);
    functions[entry.key] = visitor.build();
  }

  for (final entry in script.implementations.entries) {
    final visitor = compiler(script.globals);
    entry.value.accept(visitor);
    impls[entry.key] = visitor.build();
  }

  for (final entry in script.hooks.entries) {
    final visitor = compiler(script.globals);
    entry.value.accept(visitor);
    hooks[entry.key] = visitor.build();
  }

  return CompiledScript(
    functions: functions,
    implementations: impls,
    hooks: hooks,
    permissions: script.permissions,
    contract: script.contract,
    metadata: script.metadata,
  );
}

/// Base class for compiling Dscript code into bytecode.
abstract class Compiler extends dscriptVisitor<void> {
  /// Base class for compiling Dscript code into bytecode.
  Compiler(List<VarDeclContext> globals) {
    // add predefined global variables to the constant pool
    // add them first so they can be overridden by user-defined globals
    for (final global in TypeScope.globals.entries) {
      final idx = addConstant(global.value.$1);
      // add the variable to the current stack frame
      final varIdx = push(global.key);

      // store the variable

      emit(Instruction.pushConstant, idx);

      emit(
        Instruction.store,
        varIdx.frame,
        varIdx.index,
      );
    }

    for (final global in globals) {
      global.accept(this);
    }
  }

  /// Number of positional parameters for the function being compiled.
  int positionalParams = 0;

  /// Mapping of named parameter to its stack index.
  final Map<String, int> namedParameterIndex = {};

  /// Builds the compiled bytecode function.
  BytecodeFunction build() {
    if (_loops.isNotEmpty) {
      throw StateError('Unclosed loops detected: ${_loops.length}');
    }

    return BytecodeFunction(
      buffer,
      constants,
      positionalParams: positionalParams,
      namedParameterIndex: Map.unmodifiable(namedParameterIndex),
    );
  }

  /// The current constant pool.
  final List<Object?> constants = [];

  /// The code buffer for the compiled function.
  final List<int> _buffer = [];

  /// Stack of loop markers, where each key is the position in the buffer where a loop starts,
  /// and the value is a list of indices representing a break statment (aka jump) that needs to be updated
  /// to the end of the loop when [endLoop] is called.
  final Map<int, List<int>> _loops = {};

  /// Jump instructions generated by `continue` statements within each loop.
  ///
  /// The key is the start index of the loop and the value is a list of jump
  /// instruction indices that should point to the position directly before the
  /// loop increment step.
  final Map<int, List<int>> _continues = {};

  final List<List<String>> _stackFrames = [
    [],
  ];

  /// Marks the beginning of a loop.
  ///
  /// Stores the current buffer length to be used as a jump target for loop operations.
  /// This position can be referenced when emitting jump instructions.
  ///
  /// Call this method to start a loop before emitting any instructions that evaluate the loop condition or body.
  void startLoop() {
    final start = _buffer.length;
    _loops[start] = [];
    _continues[start] = [];
  }

  /// Ends the current innermost loop.
  ///
  /// Removes the last loop marker from the stack.
  ///
  /// Throws a [StateError] if there are no active loops to end.
  void endLoop() {
    if (_loops.isEmpty) {
      throw StateError('No loop to end.');
    }
    final loop = _loops.entries.last;
    _loops.remove(loop.key);
    final continueJumps = _continues.remove(loop.key) ?? [];

    // finalize continue jumps to the loop start for while loops where no
    // explicit continue target was set.
    for (final jumpIndex in continueJumps) {
      _buffer[jumpIndex + 1] = loop.key;
    }

    // update all jump instructions that were waiting for this loop to end
    for (final jumpIndex in loop.value) {
      finalizeJump(jumpIndex);
    }
  }

  /// Emits a jump instruction to break the current innermost loop.
  ///
  /// This method prepares a jump instruction that will skip the loop body
  /// and continue execution after the loop.
  ///
  /// Throws a [StateError] if there are no active loops to break.
  void breakLoop() {
    if (_loops.isEmpty) {
      throw StateError('No loop to break.');
    }
    final loopStart = _loops.keys.last;
    final jumpIndex = prepareJump(Instruction.jump);
    _loops[loopStart]!.add(jumpIndex);
  }

  /// Emits a jump instruction targeting the start of the current innermost loop.
  ///
  /// By default, emits a standard jump instruction ([Instruction.jump]),
  /// but an alternative instruction can be provided.
  ///
  /// Throws a [StateError] if there are no active loops to jump to.
  void jumpToLoopStart([int instruction = Instruction.jump]) {
    if (_loops.isEmpty) {
      throw StateError('No loop to jump to.');
    }
    final loopStart = _loops.keys.last;
    emit(instruction, loopStart);
  }

  /// Emits a jump instruction targeting the continue position of the current
  /// innermost loop.
  void continueLoop() {
    if (_loops.isEmpty) {
      throw StateError('No loop to continue.');
    }
    final loopStart = _loops.keys.last;
    final jumps = _continues[loopStart]!;
    final jumpIndex = prepareJump(Instruction.jump);
    jumps.add(jumpIndex);
  }

  /// Marks the current position as the continue target for the innermost loop.
  void markContinueTarget() {
    if (_loops.isEmpty) {
      throw StateError('No loop to mark.');
    }
    final loopStart = _loops.keys.last;
    final jumps = _continues[loopStart]!;
    for (final jumpIndex in jumps) {
      finalizeJump(jumpIndex);
    }
    jumps.clear();
  }

  /// Index of the current stack frame.
  int get currentFrame => _stackFrames.length - 1;

  /// Adds a constant to the pool and returns its index.
  int addConstant(Object? value) {
    if (constants.contains(value)) {
      return constants.indexOf(value);
    }

    final index = constants.length;
    constants.add(value);
    return index;
  }

  /// Pushes a new stack frame onto the stack.
  void frame() {
    _stackFrames.add([]);
  }

  /// Pops the top stack frame from the stack.
  void pop() {
    // do not pop
    if (_stackFrames.isNotEmpty && _stackFrames.length > 1) {
      _stackFrames.removeLast();
    }
  }

  /// Returns a [FrameIndex] for a new variable [name] in the current stack frame.
  FrameIndex push(String name) {
    final frameIndex = _stackFrames.length - 1;
    _stackFrames.last.add(name);
    final variableIndex = _stackFrames.last.length - 1;
    return (frame: frameIndex, index: variableIndex);
  }

  /// Returns a [FrameIndex] for the given variable [name].
  FrameIndex of(String name) {
    for (var i = _stackFrames.length - 1; i >= 0; i--) {
      final frame = _stackFrames[i];
      final index = frame.indexOf(name);
      if (index != -1) {
        return (frame: i, index: index);
      }
    }
    throw ArgumentError('Variable "$name" not found in stack frames.');
  }

  /// Adds an [instruction] to the buffer with the given arguments.
  void emit(
    int instruction, [
    int? arg1,
    int? arg2,
    int? arg3,
    int? arg4,
    int? arg5,
  ]) {
    _buffer.add(instruction);

    if (arg1 != null) _buffer.add(arg1);
    if (arg2 != null) _buffer.add(arg2);
    if (arg3 != null) _buffer.add(arg3);
    if (arg4 != null) _buffer.add(arg4);
    if (arg5 != null) _buffer.add(arg5);
  }

  /// The instruction buffer.
  Uint64List get buffer => Uint64List.fromList(_buffer);

  /// Starts a counter for jump instructions. Returns the index of the jump instruction.
  ///
  /// Call this method before emitting instructions that may be jumped over,
  /// such as conditional jumps or loops.
  ///
  /// Call [finalizeJump] to finalize the jump instruction and calculate the target index.
  int prepareJump(int instruction) {
    final jumpIndex = _buffer.length;
    emit(instruction, 0); // Placeholder for jump target
    return jumpIndex;
  }

  /// Finalizes a jump instruction at the given [jumpIndex].
  ///
  /// This method should be called after emitting the instructions that the jump instruction will skip over.
  /// It calculates the target index for the jump instruction and updates the instruction in the buffer.
  void finalizeJump(int jumpIndex) {
    // Update the jump instruction to point to the last instruction in the buffer.
    // now need to decrement the jump index by 1 because we want to point to the last *future* instruction
    // as the last instruction that is currently in the buffer is still part of a branch that will be skipped.
    // Thus, we need to point to the next instruction that will be added, which is the current length of the buffer.
    _buffer[jumpIndex + 1] = _buffer.length;
  }

  // #region No-ops

  /// No-op. The compiler does not care about metadata.
  @override
  visitVersion(VersionContext ctx) {}

  /// No-op. The compiler does not care about metadata.
  @override
  visitWebsite(WebsiteContext ctx) {}

  /// No-op. The compiler does not care about metadata.
  @override
  visitAuthor(AuthorContext ctx) {}

  /// No-op. The compiler does not care about metadata.
  @override
  visitLicense(LicenseContext ctx) {}

  /// No-op. The compiler does not care about metadata.
  @override
  visitDescription(DescriptionContext ctx) {}

  /// No-op. The compiler does not care about metadata.
  @override
  visitPermission(PermissionContext ctx) {}

  /// No-op. The compiler does not care about metadata.
  @override
  visitPermissions(PermissionsContext ctx) {}

  /// No-op. The compiler does not care about metadata.
  @override
  visitRepo(RepoContext ctx) {}

  /// No-op. The compiler does not care about metadata.
  @override
  visitName(NameContext ctx) {}

  /// No-op. The compiler does not care about metadata.
  @override
  void visitMetadata(MetadataContext ctx) {}

  /// No-op. The compiler does not care about the contract itself.
  @override
  visitContract(ContractContext ctx) {}

  /// No-op. The compiler does not care about data types.
  @override
  visitDataType(DataTypeContext ctx) {}

  /// No-op.
  @override
  visitSchema(SchemaContext ctx) {}

  /// No-op.
  @override
  visitScript(ScriptContext ctx) {}

  //#endregion
}

/// Represents a frame index in the stack.
/// It is a tuple of two integers: the frame index and the variable index within that frame.
/// This is used to track the position of variables in the stack frames during compilation.
typedef FrameIndex = ({int frame, int index});
